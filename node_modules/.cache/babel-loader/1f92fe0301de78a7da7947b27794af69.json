{"ast":null,"code":"var token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n  try {\n    // Try to decode the entire string first\n    return [decodeURIComponent(components.join(''))];\n  } catch (_unused) {// Do nothing\n  }\n\n  if (components.length === 1) {\n    return components;\n  }\n\n  split = split || 1; // Split the array in 2 parts\n\n  var left = components.slice(0, split);\n  var right = components.slice(split);\n  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input);\n  } catch (_unused2) {\n    var tokens = input.match(singleMatcher) || [];\n\n    for (var i = 1; i < tokens.length; i++) {\n      input = decodeComponents(tokens, i).join('');\n      tokens = input.match(singleMatcher) || [];\n    }\n\n    return input;\n  }\n}\n\nfunction customDecodeURIComponent(input) {\n  // Keep track of all the replacements and prefill the map with the `BOM`\n  var replaceMap = {\n    '%FE%FF': \"\\uFFFD\\uFFFD\",\n    '%FF%FE': \"\\uFFFD\\uFFFD\"\n  };\n  var match = multiMatcher.exec(input);\n\n  while (match) {\n    try {\n      // Decode as big chunks as possible\n      replaceMap[match[0]] = decodeURIComponent(match[0]);\n    } catch (_unused3) {\n      var result = decode(match[0]);\n\n      if (result !== match[0]) {\n        replaceMap[match[0]] = result;\n      }\n    }\n\n    match = multiMatcher.exec(input);\n  } // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\n\n  replaceMap['%C2'] = \"\\uFFFD\";\n  var entries = Object.keys(replaceMap);\n\n  for (var _i = 0, _entries = entries; _i < _entries.length; _i++) {\n    var key = _entries[_i];\n    // Replace all decoded components\n    input = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n  }\n\n  return input;\n}\n\nexport default function decodeUriComponent(encodedURI) {\n  if (typeof encodedURI !== 'string') {\n    throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n  }\n\n  try {\n    // Try the built in decoder first\n    return decodeURIComponent(encodedURI);\n  } catch (_unused4) {\n    // Fallback to a more advanced decoder\n    return customDecodeURIComponent(encodedURI);\n  }\n}","map":{"version":3,"sources":["D:/funix/NJS301x_1.0-A_VN Lập trình Web Back-End với NodeJS/assignment 03/Frontend Assignemnt 03 Admin App/node_modules/query-string/node_modules/decode-uri-component/index.js"],"names":["token","singleMatcher","RegExp","multiMatcher","decodeComponents","components","split","decodeURIComponent","join","length","left","slice","right","Array","prototype","concat","call","decode","input","tokens","match","i","customDecodeURIComponent","replaceMap","exec","result","entries","Object","keys","key","replace","decodeUriComponent","encodedURI","TypeError"],"mappings":"AAAA,IAAMA,KAAK,GAAG,cAAd;AACA,IAAMC,aAAa,GAAG,IAAIC,MAAJ,CAAW,MAAMF,KAAN,GAAc,YAAzB,EAAuC,IAAvC,CAAtB;AACA,IAAMG,YAAY,GAAG,IAAID,MAAJ,CAAW,MAAMF,KAAN,GAAc,IAAzB,EAA+B,IAA/B,CAArB;;AAEA,SAASI,gBAAT,CAA0BC,UAA1B,EAAsCC,KAAtC,EAA6C;AAC5C,MAAI;AACH;AACA,WAAO,CAACC,kBAAkB,CAACF,UAAU,CAACG,IAAX,CAAgB,EAAhB,CAAD,CAAnB,CAAP;AACA,GAHD,CAGE,gBAAM,CACP;AACA;;AAED,MAAIH,UAAU,CAACI,MAAX,KAAsB,CAA1B,EAA6B;AAC5B,WAAOJ,UAAP;AACA;;AAEDC,EAAAA,KAAK,GAAGA,KAAK,IAAI,CAAjB,CAZ4C,CAc5C;;AACA,MAAMI,IAAI,GAAGL,UAAU,CAACM,KAAX,CAAiB,CAAjB,EAAoBL,KAApB,CAAb;AACA,MAAMM,KAAK,GAAGP,UAAU,CAACM,KAAX,CAAiBL,KAAjB,CAAd;AAEA,SAAOO,KAAK,CAACC,SAAN,CAAgBC,MAAhB,CAAuBC,IAAvB,CAA4B,EAA5B,EAAgCZ,gBAAgB,CAACM,IAAD,CAAhD,EAAwDN,gBAAgB,CAACQ,KAAD,CAAxE,CAAP;AACA;;AAED,SAASK,MAAT,CAAgBC,KAAhB,EAAuB;AACtB,MAAI;AACH,WAAOX,kBAAkB,CAACW,KAAD,CAAzB;AACA,GAFD,CAEE,iBAAM;AACP,QAAIC,MAAM,GAAGD,KAAK,CAACE,KAAN,CAAYnB,aAAZ,KAA8B,EAA3C;;AAEA,SAAK,IAAIoB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAACV,MAA3B,EAAmCY,CAAC,EAApC,EAAwC;AACvCH,MAAAA,KAAK,GAAGd,gBAAgB,CAACe,MAAD,EAASE,CAAT,CAAhB,CAA4Bb,IAA5B,CAAiC,EAAjC,CAAR;AAEAW,MAAAA,MAAM,GAAGD,KAAK,CAACE,KAAN,CAAYnB,aAAZ,KAA8B,EAAvC;AACA;;AAED,WAAOiB,KAAP;AACA;AACD;;AAED,SAASI,wBAAT,CAAkCJ,KAAlC,EAAyC;AACxC;AACA,MAAMK,UAAU,GAAG;AAClB,cAAU,cADQ;AAElB,cAAU;AAFQ,GAAnB;AAKA,MAAIH,KAAK,GAAGjB,YAAY,CAACqB,IAAb,CAAkBN,KAAlB,CAAZ;;AACA,SAAOE,KAAP,EAAc;AACb,QAAI;AACH;AACAG,MAAAA,UAAU,CAACH,KAAK,CAAC,CAAD,CAAN,CAAV,GAAuBb,kBAAkB,CAACa,KAAK,CAAC,CAAD,CAAN,CAAzC;AACA,KAHD,CAGE,iBAAM;AACP,UAAMK,MAAM,GAAGR,MAAM,CAACG,KAAK,CAAC,CAAD,CAAN,CAArB;;AAEA,UAAIK,MAAM,KAAKL,KAAK,CAAC,CAAD,CAApB,EAAyB;AACxBG,QAAAA,UAAU,CAACH,KAAK,CAAC,CAAD,CAAN,CAAV,GAAuBK,MAAvB;AACA;AACD;;AAEDL,IAAAA,KAAK,GAAGjB,YAAY,CAACqB,IAAb,CAAkBN,KAAlB,CAAR;AACA,GArBuC,CAuBxC;;;AACAK,EAAAA,UAAU,CAAC,KAAD,CAAV,GAAoB,QAApB;AAEA,MAAMG,OAAO,GAAGC,MAAM,CAACC,IAAP,CAAYL,UAAZ,CAAhB;;AAEA,8BAAkBG,OAAlB,8BAA2B;AAAtB,QAAMG,GAAG,eAAT;AACJ;AACAX,IAAAA,KAAK,GAAGA,KAAK,CAACY,OAAN,CAAc,IAAI5B,MAAJ,CAAW2B,GAAX,EAAgB,GAAhB,CAAd,EAAoCN,UAAU,CAACM,GAAD,CAA9C,CAAR;AACA;;AAED,SAAOX,KAAP;AACA;;AAED,eAAe,SAASa,kBAAT,CAA4BC,UAA5B,EAAwC;AACtD,MAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC;AACnC,UAAM,IAAIC,SAAJ,CAAc,wDAAwD,OAAOD,UAA/D,GAA4E,GAA1F,CAAN;AACA;;AAED,MAAI;AACH;AACA,WAAOzB,kBAAkB,CAACyB,UAAD,CAAzB;AACA,GAHD,CAGE,iBAAM;AACP;AACA,WAAOV,wBAAwB,CAACU,UAAD,CAA/B;AACA;AACD","sourcesContent":["const token = '%[a-f0-9]{2}';\nconst singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');\nconst multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn [decodeURIComponent(components.join(''))];\n\t} catch {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tconst left = components.slice(0, split);\n\tconst right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch {\n\t\tlet tokens = input.match(singleMatcher) || [];\n\n\t\tfor (let i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher) || [];\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tconst replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD',\n\t};\n\n\tlet match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch {\n\t\t\tconst result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tconst entries = Object.keys(replaceMap);\n\n\tfor (const key of entries) {\n\t\t// Replace all decoded components\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nexport default function decodeUriComponent(encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}